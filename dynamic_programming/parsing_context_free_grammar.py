# Parsing a Context Free Grammar
# Input: A given text sequence S and a context free grammar G.
# Output: A boolean indicating whether a parse tree exists for S according to G.
# Subproblem: M[i, j, X] is a boolean indicating whether S[i:j] is generated by X.
# Intuition: The rule applied at the root of the parse tree (say X -> YZ) splits S at some point i such
#            that the left part S[1:i] is generated by Y and the right part S[i+1:n] is generated by Z.
# Recurrence: M[i, j, X] = OR{M[i, k, Y] AND M[k+1, j, Z] for all rules X -> YZ}
# Boundary conditions: Defined by all terminal symbols in the grammar, see code.
# Efficiency: O(N^3) time. The state space is all i,j pairs which is O(N^2), and for each state we
#             consider all positions k which is O(N).
# References:
#   - Algorithm Design Manual (Skiena) Section 10.8


import numpy as np

def parse_context_free_grammar(S: list[str], G: dict[str, list]) -> list[list[int]]:

    M = np.zeros((len(S), len(S), len(G)), dtype=bool)
   
    # Boundary conditions
    for i in range(len(S)):
        for X in G:
            if S[i] in G[X]:
                M[i, i, list(G.keys()).index(X)] = True                

    # Recurrence
    ############   

    # Loop over all rules.
    for X in G:
        
        # Skip terminal symbols - these are already set by the boundary conditions.
        if X in ['ARTICLE', 'NOUN', 'VERB']:
            continue
        
        Y, Z = G[X][0].split(" ")
        _Y = list(G.keys()).index(Y)
        _Z = list(G.keys()).index(Z)

        _X = list(G.keys()).index(X)

        # Loop over all substrings.
        for i in range(len(S)):
            for j in range(i, len(S)):
                
                # Try all possible splits.
                M[i, j, _X] = any([M[i, k, _Y] and M[k+1, j, _Z] for k in range(i, j)])
                    

    return M[0, len(S)-1, list(G.keys()).index('SENTENCE')]


def run():

    # Input
    S = ["the", "cat", "drank", "the", "milk"]
    G = {
        "NOUN-PHRASE": ["ARTICLE NOUN"],
        "VERB-PHRASE": ["VERB NOUN-PHRASE"],
        "SENTENCE": ["NOUN-PHRASE VERB-PHRASE"],
        "ARTICLE": ["the", "a"],
        "NOUN": ["cat", "dog", "milk"],
        "VERB": ["drank", "ate"]
    }

    # # Output
    tree = parse_context_free_grammar(S, G)
    print(tree)
    

if __name__ == '__main__':
    run()