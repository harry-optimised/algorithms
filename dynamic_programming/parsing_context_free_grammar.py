# Parsing a Context Free Grammar
# Input: A given text sequence S and a context free grammar G.
# Output: A parse tree for S according to G.
# Subproblem: M[i, j, X] is a boolean indicating whether S[i:j] is generated by X.
# Intuition: The rule applied at the root of the parse tree (say X -> YZ) splits S at some point i such
#            that the left part S[1:i] is generated by Y and the right part S[i+1:n] is generated by Z.
# Recurrence: M[i, j, X] = OR{M[i, k, Y] AND M[k+1, j, Z] for all rules X -> YZ}
# Boundary conditions: Defined by all terminal symbols in the grammar, see code.
# Efficiency: O(N^3) time. The state space is all i,j pairs which is O(N^2), and for each state we
#             consider all positions k which is O(N).
# References:
#   - Algorithm Design Manual (Skiena) Section 10.8


import numpy as np
from anytree import Node, RenderTree  # Requires anytre==2.12.1

def parse_context_free_grammar(S: list[str], G: dict[str, list]) -> list[list[int]]:

    M = np.zeros((len(S), len(S), len(G)), dtype=bool)
    reconstruction = []

    # Boundary conditions
    for i in range(len(S)):
        for X in G:
            if S[i] in G[X]:
                M[i, i, list(G.keys()).index(X)] = True
                reconstruction.append([f"{X}_{i}{i}", S[i]])

    # Recurrence
    ############   

    # Loop over all rules.
    for X in G:
        
        # Skip terminal symbols - these are already set by the boundary conditions.
        if X in ['ARTICLE', 'NOUN', 'VERB']:
            continue
        
        Y, Z = G[X][0].split(" ")
        _Y = list(G.keys()).index(Y)
        _Z = list(G.keys()).index(Z)

        _X = list(G.keys()).index(X)

        # Loop over all substrings.
        for i in range(len(S)):
            for j in range(i, len(S)):
                
                # Try all possible splits.
                for k in range(i, j):
                    M[i, j, _X] = M[i, k, _Y] and M[k+1, j, _Z]
                    if M[i, j, _X]:
                        reconstruction.append([f"{X}_{i}{j}", f"{Y}_{i}{k}", f"{Z}_{k+1}{j}"])
                        break
                

    # Construct the parse tree.
    ###########################
    
    nodes = {}

    for r in reconstruction:

        if len(r) == 3:            
            X, Y, Z = r
        else: 
            X, Y = r
            Z = None

        if X not in nodes:
            nodes[X] = Node(X)

        if Y not in nodes:
            nodes[Y] = Node(Y, parent=nodes[X])
        else:
            nodes[Y].parent = nodes[X]

        if not Z:
            continue
        
        if Z not in nodes:
            nodes[Z] = Node(Z, parent=nodes[X])
        else:
            nodes[Z].parent = nodes[X]


    # Assume root is node with 'SENTENCE' in name.
    root = None
    for n in nodes:
        if 'SENTENCE' in n:
            root = nodes[n]
            break
    
    return root
    
    

def run():

    # Input
    S = ["the", "cat", "drank", "the", "milk"]
    G = {
        "NOUN-PHRASE": ["ARTICLE NOUN"],
        "VERB-PHRASE": ["VERB NOUN-PHRASE"],
        "SENTENCE": ["NOUN-PHRASE VERB-PHRASE"],
        "ARTICLE": ["the", "a"],
        "NOUN": ["cat", "dog", "milk"],
        "VERB": ["drank", "ate"]
    }

    # # Output
    tree = parse_context_free_grammar(S, G)
    for pre, _, node in RenderTree(tree):
        print(f"{pre}{node.name}")
    

if __name__ == '__main__':
    run()